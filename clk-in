#!/usr/bin/perl
use strict;
use warnings;
use IPC::Open2;
use App::Clk::Util qw( clk_root resolve_instant );

# process command line arguments
my $storing_entry = 1;
our $time = $ENV{CLK_TIME} || time;
my $i = 0;
while ( $i <= $#ARGV ) {
    if ( $ARGV[$i] eq '--at' ) {
        die "--at requires an argument\n" if $i + 1 > $#ARGV;
        my $instant = $ARGV[ $i + 1 ];
        local $@;
        $time = eval { resolve_instant($instant) };
        die "Invalid instant for --at: $instant\n" if not defined $time;
        splice @ARGV, $i, 2;    # remove the processed arguments
        next;
    }
    if ( $ARGV[$i] eq '--output-only' ) {
        $storing_entry = 0;
        splice @ARGV, $i, 1;  # remove the processed argument
        next;
    }

    # found no known options.  move on to the next argument
    $i++;
}

# generate the entry text which follows the time stamp
my $entry_text;
if ( my $hook = get_hook('pre-in') ) {
    $entry_text = qx{ $hook @ARGV 2>&1 };
    die "Unable to run the 'pre-in' hook at $hook\n"
        if not defined $entry_text;
    if ($?) {
        my $message = defined $entry_text ? $entry_text : '';
        chomp $message;
        warn "The hook 'pre-in' stopped the entry with the message:\n"
           . "$message\n";
        exit($? >> 8);
    }
}
elsif ( looks_like_partial_entry_id( $ARGV[0] ) ) {
    open my $search,
        "./clk entry-search --output content $ARGV[0] 2>/dev/null |";
    my $content;
    while ( my $line = <$search> ) {
        next unless $line =~ m/^content (\d+)$/;
        my $actually_read = read $search, $content, $1;
        die "Tried to read $1 characters, but got $actually_read\n"
            if $actually_read != $1;
        last;
    }
    close $search;
    if ($content) {
        $entry_text = join "\n", grep { !/^time: / } split(/\n/, $content, -1);
    }
}
if ( not defined $entry_text ) {
    $entry_text = 'text: ' . join(' ', @ARGV) . "\n" if @ARGV;
}

# set up filehandles based on whether the entry should be saved
my ( $pid, $reader, $writer );
if ($storing_entry) {    # send output to clk-store-entry
    $pid = open2( $reader, $writer, 'clk-store-entry', './play' );
}
else {                   # send output to STDOUT
    $writer = \*STDOUT;
}

# print the full entry content
my @parts = (gmtime $time)[ 0 .. 5];
$parts[4]++;  # use human-readable day
$parts[5] += 1900; # ... and year
printf {$writer} "time: %04d-%02d-%02dT%02d:%02d:%02dZ\n", reverse @parts;
printf {$writer} "identity: %s\n", $ENV{CLK_IDENTITY}
    unless defined($entry_text) and $entry_text =~ m/^identity:/xms;
print {$writer} $entry_text if defined $entry_text;

# if storing the entry, output its entry ID
if ($storing_entry) {
    close $writer;    # send EOF
    my $entry_id = <$reader>;
    waitpid $pid, 0;
    print $entry_id if $entry_id;
}

##########################################################################

sub get_hook {
    my ($hook_name) = @_;
    my $root        = clk_root();
    my $path        = "$root/hooks/$hook_name";
    return $path if -x $path;
    return;
}

sub looks_like_partial_entry_id {
    my ($maybe) = @_;
    return if not defined $maybe;
    return $maybe =~ m/^[0-9a-f]{3,40}$/;
}

__END__

=head1 NAME

clk-in - Begin recording time for a task

=head1 SYNOPSIS

B<clk in> [--at instant] [--output-only] [text...]

=head1 DESCRIPTION

Create a new entry to record the current time with an optional C<text>.  When
beginning to work on a new task, the start time should be recorded by running
I<clk in>.  By default, the current time is recorded.  Any words that are not
interpreted as options or associated arguments are joined with spaces and
considered part of the C<text>.

=head1 OPTIONS

=head2 --at instant

Instead of creating an entry with the current time, create an entry
at the time specified by C<instant>.  See L<specs> for a list of valid
instant formats.

C<--at> takes precedence over any time specified with the C<CLK_TIME>
environment variable.

=head2 --output-only

Only display the new entry's content on STDOUT, don't put a copy in the entry
store.  This option is mostly useful for testing and scripting.  Without
this option, I<clk in> sends the entry content to L<clk-store-entry> to
be saved in the entry store.

=head1 HOOKS

=head2 pre-in

This hook is run right before a new entry is generated.  All arguments
provided to C<clk-in> which are not listed in the L</OPTIONS> section
are passed through to this hook.  If the hook exits with 0, the hook's
standard output is used as the content for the new entry.  If the hook exits
with a non-zero exit code, C<clk-in> exits with a message before the
new entry is created.

This hook can be used to create specific entry content based on personal
preferences.  For instance, if you want to record time spent working on
projects for 'Intel Corporation' (abbreviated "intc") by tagging them with a
specify entry key, you could create a C<pre-in> hook script like this:

    #!/usr/bin/perl
    my $text = join ' ', @ARGV;
    if ( $text =~ s{\b intc \b}{}x ) {
        print "client: Intel Corporation\n";
    }
    print "text: $text\n":

which would cause something like:

    $ clk in --output-only intc processor design
    time: 2008-07-14T19:47:31Z
    client: Intel Corporation
    text: processor design

=head1 EXIT CODES

 0   - the command executed successfully
 *   - the pre-in hook stopped the command prematurely and this was its
       exit code.  In other words, if the pre-in hook exits non-zero,
       clk-in exits with the same code.
 255 - an unknown error occurred.  Check the command output for details

#!/usr/bin/perl
use strict;
use warnings;

# process command line arguments
my %acceptable_outputs = map { $_ => 1 } qw( content duration );
my %outputting;
our $begin;
our $end;
our $fsck;
our $tail;
my $i = 0;
while ( $i <= $#ARGV ) {
    if ( $ARGV[$i] eq '--output' ) {
        die "--output requires an argument\n" if $i + 1 > $#ARGV;
        my $spec = $ARGV[ $i + 1 ];
        for my $output ( split /,/, $spec ) {
            die "Invalid output kind: $output\n"
              unless $acceptable_outputs{$output};
            $outputting{$output} = 1;
        }
        splice @ARGV, $i, 2;    # remove the processed arguments
        next;
    }
    elsif ( $ARGV[$i] eq '--between' ) {
        die "--between requires two arguments\n" if $i + 2 > $#ARGV;
        require App::Clk::Util;
        local $@;
        my $arg = $ARGV[ $i + 1 ];
        $begin = eval { App::Clk::Util::resolve_instant($arg) };
        die "'$arg' is not a valid instant\n" if not defined $begin;
        $arg = $ARGV[ $i + 2 ];
        $end   = eval { App::Clk::Util::resolve_instant($arg) };
        die "'$arg' is not a valid instant\n" if not defined $end;
        splice @ARGV, $i, 3;    # remove the processed arguments
        next;
    }
    elsif ( $ARGV[$i] eq '--fsck' ) {
        $fsck = 1;
        splice @ARGV, $i, 1;    # remove the processed arguments
        next;
    }
    elsif ( $ARGV[$i] eq '--period' ) {
        die "--period requires an argument\n" if $i + 1 > $#ARGV;
        my $period = $ARGV[ $i + 1 ];
        require App::Clk::Util;
        local $@;
        ( $begin, $end ) = eval { App::Clk::Util::resolve_period($period) };
        die "'$period' is not a valid period\n" if not defined $begin;
        splice @ARGV, $i, 2;    # remove the processed arguments
        next;
    }
    elsif ( $ARGV[$i] eq '--tail' ) {
        die "--tail requires an argument\n" if $i + 1 > $#ARGV;
        $tail = $ARGV[ $i + 1 ];
        splice @ARGV, $i, 2;    # remove the processed arguments
        next;
    }

    # found no known options.  move on to the next argument
    $i++;
}

search_by_tail() if $tail;
search_by_time() if $begin or $end;

# default to searching by entry ID
my $entry_id = shift;
if ( not defined $entry_id ) {
    require App::Clk::Util;
    ( $begin, $end ) = App::Clk::Util::resolve_period('ever');
    search_by_time();
}
die "A partial entry ID must be at least 3 characters long\n"
    if length($entry_id) < 3;

require App::Clk::Util;
if ( length $entry_id == 40 ) {  # full entry ID
    my $entry_filename =
      App::Clk::Util::hashed_path( $entry_id, '%r/entries/%h' );
    if ( -e $entry_filename ) {
        emit($entry_filename);
        exit;
    }
}
else {  # partial entry ID
    my @entry_filenames =
      glob( App::Clk::Util::hashed_path( $entry_id, '%r/entries/%h*' ) );
    if ( @entry_filenames > 1 ) {
        warn "The partial entry ID '$entry_id' is ambiguous\n";
        exit 2;
    }
    elsif ( @entry_filenames == 1 ) {
        emit( $entry_filenames[0] );
        exit;
    }
}

exit 1;  # failure

sub emit {
    my ($entry) = @_;
    my $entry_filename;
    if ( ref $entry ) {
        require App::Clk::Util;
        my $entry_id = $entry->[1];
        $entry_filename =
          App::Clk::Util::hashed_path( $entry_id, '%r/entries/%h' );
    }
    else {
        $entry_filename = $entry;
    }
    ( my $entry_id = substr $entry_filename, -41 ) =~ y#/##d;
    print "id $entry_id\n" if $outputting{content} or $outputting{duration};
    if ( $outputting{duration} ) {
        die "TODO: Cannot output duration for a single entry\n"
            if not ref $entry;
        my $next_entry = $entry->[2]->peek;
        my $next_time = $next_entry
                        ? $next_entry->[0]
                        : ( $ENV{CLK_TIME} || time )
                        ;
        printf "duration %d\n", $next_time - $entry->[0];
    }
    if ( $outputting{content} ) {
        open my $fh, '<', $entry_filename
          or die "Couldn't open $entry_filename: $!\n";
        my $content = scalar do { local $/; <$fh> };
        printf "content %d\n%s", length($content), $content;
    }
    return if $outputting{content} or $outputting{duration};

    print "$entry_id\n";
    return;
}

sub search_by_tail {

    # build an iterator representing a unified, backwards timeline
    require App::Clk::Util;
    my $timeline =
      App::Clk::Util::iterator_timeline( $ENV{CLK_IDENTITY}, 'backwards' );

    # find matching entries
    my @found;
    while ( my $entry = $timeline->next ) {
        $entry->[2] = $timeline;
        unshift @found, $entry;
        last if @found == $tail;
    }

    emit($_) for @found;
    exit;
}

sub search_by_time {
    our $begin;
    our $end;

    # build an iterator representing a unified timeline for the user
    require App::Clk::Util;
    my $timeline = App::Clk::Util::iterator_timeline( $ENV{CLK_IDENTITY} );

    # find matching entries
    while ( my $entry = $timeline->next ) {
        next if $entry->[0] < $begin;  # too early
        last if $entry->[0] > $end;    # too late
        $entry->[2] = $timeline;
        emit($entry);
    }

    exit;
}

__END__

=head1 NAME

clk-entry-search - Search for entries created by clk-in

=head1 SYNOPSIS

B<clk entry-search> [--output 'content'] [id_pattern]

=head1 DESCRIPTION

Searches for entries which have been created by L<clk-in>.  C<id_pattern> is
either the 40 hexadecimal digit identifier for an entry or a unique prefix
thereof.  If a prefix is given, it must be at least 3 characters long.  If no
C<id_pattern> is provided, all matching entries are considered.

The entry ID for each matching entry is printed to STDOUT.

=head1 OPTIONS

=head2 --between begin end

Search for entries with times between C<begin> and C<end> (inclusive).  Each
argument should be a C<instant>.  See L<specs> for a list of valid formats.

=head2 --fsck

This option should typically not be used directly.  Instead, call C<clk fsck>
to perform a variety of integrity checks.  When this option is used, it
verifies the integrity of the timelines.

=head2 --output 'content'

Instead of printing just the entry IDs to STDOUT, include the content of each
matching entry.  The output format looks like:

    id 123456789abcdefabcdefabcdefabcdefabcdefa
    content 38
    time: 2008-09-03T12:58:32Z
    text: hello

Each matching entry starts with a line

    id $entry_id

where C<$entry_id> is the entry's 40 hexadecimal digit unique identifier.
The following line is

    content $length

where C<$length> indicates the length of the entry's content.  That many
bytes worth of content follow the newline on the C<content> line.

=head2 --period period

Search for entries with times within the specified period.  The
argument should be a C<period>.  See L<specs> for a list of accepted periods.

=head2 --tail number

Searches for the most recent C<number> entries.

=head1 EXIT CODES

 0   - At least one matching entry was found
 1   - No matching entries were found
 2   - A partial entry ID search was ambiguous
 255 - Improper invocation or another error was encountered.
       Details are provided on stderr.

#!/usr/bin/perl
use strict;
use warnings;

# process command line arguments
my %acceptable_outputs = map { $_ => 1 } qw( content duration );
my %outputting;
our $begin;
our $end;
our $fsck;
our $tail;
our $skip_deletions = 1;
my $i = 0;
while ( $i <= $#ARGV ) {
    if ( $ARGV[$i] eq '--output' ) {
        die "--output requires an argument\n" if $i + 1 > $#ARGV;
        my $spec = $ARGV[ $i + 1 ];
        for my $output ( split /,/, $spec ) {
            die "Invalid output kind: $output\n"
              unless $acceptable_outputs{$output};
            $outputting{$output} = 1;
        }
        splice @ARGV, $i, 2;    # remove the processed arguments
        next;
    }
    elsif ( $ARGV[$i] eq '--between' ) {
        die "--between requires two arguments\n" if $i + 2 > $#ARGV;
        require App::Clk::Util;
        local $@;
        my $arg = $ARGV[ $i + 1 ];
        $begin = eval { App::Clk::Util::resolve_instant($arg) };
        die "'$arg' is not a valid instant\n" if not defined $begin;
        $arg = $ARGV[ $i + 2 ];
        $end   = eval { App::Clk::Util::resolve_instant($arg) };
        die "'$arg' is not a valid instant\n" if not defined $end;
        splice @ARGV, $i, 3;    # remove the processed arguments
        next;
    }
    elsif ( $ARGV[$i] eq '--fsck' ) {
        $fsck = 1;
        splice @ARGV, $i, 1;    # remove the processed arguments
        next;
    }
    elsif ( $ARGV[$i] eq '--include-deletions' ) {
        $skip_deletions = 0;
        splice @ARGV, $i, 1;    # remove the processed arguments
        next;
    }
    elsif ( $ARGV[$i] eq '--period' ) {
        die "--period requires an argument\n" if $i + 1 > $#ARGV;
        my $period = $ARGV[ $i + 1 ];
        require App::Clk::Util;
        local $@;
        ( $begin, $end ) = eval { App::Clk::Util::resolve_period($period) };
        die "'$period' is not a valid period\n" if not defined $begin;
        splice @ARGV, $i, 2;    # remove the processed arguments
        next;
    }
    elsif ( $ARGV[$i] eq '--tail' ) {
        die "--tail requires an argument\n" if $i + 1 > $#ARGV;
        $tail = $ARGV[ $i + 1 ];
        splice @ARGV, $i, 2;    # remove the processed arguments
        next;
    }

    # found no known options.  move on to the next argument
    $i++;
}

search_by_tail() if $tail;
search_by_time() if $begin or $end;

# default to searching by entry ID
my $entry_id = shift;
if ( not defined $entry_id ) {
    require App::Clk::Util;
    ( $begin, $end ) = App::Clk::Util::resolve_period('ever');
    search_by_time();
}
die "A partial entry ID must be at least 3 characters long\n"
    if length($entry_id) < 3;

require App::Clk::Util;
if ( length $entry_id == 40 ) {  # full entry ID
    my $entry_filename =
      App::Clk::Util::hashed_path( $entry_id, '%r/entries/%h' );
    if ( -e $entry_filename ) {
        emit($entry_filename);
        exit;
    }
}
else {  # partial entry ID
    my @entry_filenames =
      glob( App::Clk::Util::hashed_path( $entry_id, '%r/entries/%h*' ) );
    if ( @entry_filenames > 1 ) {
        warn "The partial entry ID '$entry_id' is ambiguous\n";
        exit 2;
    }
    elsif ( @entry_filenames == 1 ) {
        emit( $entry_filenames[0] );
        exit;
    }
}

exit 1;  # failure

sub emit {
    my ($entry) = @_;
    require App::Clk::Util;
    my $entry_filename;
    if ( ref $entry ) {
        my $entry_id = $entry->[1];
        $entry_filename =
          App::Clk::Util::hashed_path( $entry_id, '%r/entries/%h' );
    }
    else {
        $entry_filename = $entry;
    }
    ( my $entry_id = substr $entry_filename, -41 ) =~ y#/##d;
    return if  $skip_deletions
           and App::Clk::Util::is_deleted_entry($entry_id);
    print "id $entry_id\n" if $outputting{content} or $outputting{duration};
    if ( $outputting{duration} ) {
        if ( not ref $entry ) {
            printf "duration %d\n",
              single_entry_duration( $entry, $entry_filename );
        }
        else {
            my $next_entry =
              exists $entry->[3] ? $entry->[3] : $entry->[2]->peek;
            require App::Clk::Util;
            my $next_time = $next_entry
                            ? $next_entry->[0]
                            : App::Clk::Util::now()
                            ;
            printf "duration %d\n", $next_time - $entry->[0];
        }
    }
    if ( $outputting{content} ) {
        open my $fh, '<', $entry_filename
          or die "Couldn't open $entry_filename: $!\n";
        my $content = scalar do { local $/; <$fh> };
        printf "content %d\n%s", length($content), $content;
    }
    return if $outputting{content} or $outputting{duration};

    print "$entry_id\n";
    return;
}

sub single_entry_duration {
    my ( $entry_id, $entry_filename ) = @_;
    require App::Clk::Util;

    # find the entry time
    open my $fh, '<', $entry_filename
        or die "Couldn't open $entry_filename: $!\n";
    my ($time) = map { /^time: (.*)$/ ? $1 : () } <$fh>;
    $time = App::Clk::Util::to_localtime($time);
    close $fh;
    die "Unable to find the time for $entry_id\n" if not $time;

    # find the first entry after that time
    my $entries = App::Clk::Util::entry_search({
        between => [ $time, App::Clk::Util::now() ],
    });
    my $following_time;
    while ( my $entry = $entries->next ) {
        next if $entry_id eq $entry->id;
        $following_time = $entry->time;
        last;
    }
    $following_time ||= App::Clk::Util::now();

    # subtract the two
    return $following_time - $time;
}

sub search_by_tail {

    # build an iterator representing a unified, backwards timeline
    require App::Clk::Util;
    my $timeline =
      App::Clk::Util::iterator_timeline( $ENV{CLK_IDENTITY}, 'backwards' );

    # find matching entries
    my @found;
    while ( my $entry = $timeline->next ) {
        $entry->[2] = $timeline;
        $entry->[3] = $found[0];  # the one that follows us chronologically
        unshift @found, $entry;
        last if @found == $tail;
    }

    emit($_) for @found;
    exit;
}

sub search_by_time {
    our $begin;
    our $end;

    # build an iterator representing a unified timeline for the user
    require App::Clk::Util;
    my $timeline = App::Clk::Util::iterator_timeline( $ENV{CLK_IDENTITY} );

    # find matching entries
    while ( my $entry = $timeline->next ) {
        next if $entry->[0] < $begin;  # too early
        last if $entry->[0] > $end;    # too late
        $entry->[2] = $timeline;
        emit($entry);
    }

    exit;
}

__END__

=head1 NAME

clk-entry-search - Search for entries created by clk-in

=head1 SYNOPSIS

B<clk entry-search> [--output 'content'] [id_pattern]

=head1 DESCRIPTION

Searches for entries which have been created by L<clk-in>.  C<id_pattern> is
either the 40 hexadecimal digit identifier for an entry or a unique prefix
thereof.  If a prefix is given, it must be at least 3 characters long.  If no
C<id_pattern> is provided, all matching entries are considered.

The entry ID for each matching entry is printed to STDOUT.

=head1 OPTIONS

=head2 --between begin end

Search for entries with times between C<begin> and C<end> (inclusive).  Each
argument should be a C<instant>.  See L<specs> for a list of valid formats.

=head2 --fsck

This option should typically not be used directly.  Instead, call C<clk fsck>
to perform a variety of integrity checks.  When this option is used, it
verifies the integrity of the timelines.

=head2 --output LIST

C<LIST> is a comma-separated list of the information that you want included in
the output.  Acceptable values and their meanings are described next.

=head3 content

Instead of printing just the entry IDs to STDOUT, include the content of each
matching entry.  The output format looks like:

    id 123456789abcdefabcdefabcdefabcdefabcdefa
    content 38
    time: 2008-09-03T12:58:32Z
    text: hello

Each matching entry starts with a line

    id $entry_id

where C<$entry_id> is the entry's 40 hexadecimal digit unique identifier.
The following line is

    content $length

where C<$length> indicates the length of the entry's content.  That many
bytes worth of content follow the newline on the C<content> line.

=head3 duration

Similar in format to L</content>, specifying 'duration' includes a line like

    duration 1234

immediately after the 'id' line.  It specifies the time, in seconds, between
this entry and the next one.  If there is no next entry, it indicates the time
that has passed since this entry was created.

=head2 --include-deletions

Search results usually exclude entries which have been marked as deleted.
With this option, those entries are shown as though they were normal entries.

=head2 --period period

Search for entries with times within the specified period.  The
argument should be a C<period>.  See L<specs> for a list of accepted periods.

=head2 --tail number

Searches for the most recent C<number> entries.

=head1 EXIT CODES

 0   - At least one matching entry was found
 1   - No matching entries were found
 2   - A partial entry ID search was ambiguous
 255 - Improper invocation or another error was encountered.
       Details are provided on stderr.

#!/usr/bin/perl
use strict;
use warnings;

# process command line arguments
my $outputting_content = 0;
our $begin;
our $end;
my $i = 0;
while ( $i <= $#ARGV ) {
    if ( $ARGV[$i] eq '--output' ) {
        die "--output requires an argument\n" if $i + 1 > $#ARGV;
        my $spec = $ARGV[ $i + 1 ];
        die "Invalid output spec: $spec\n" if $spec ne 'content';
        $outputting_content = 1;
        splice @ARGV, $i, 2;    # remove the processed arguments
        next;
    }
    elsif ( $ARGV[$i] eq '--between' ) {
        die "--between requires two arguments\n" if $i + 2 > $#ARGV;
        require App::Clk::Util;
        local $@;
        my $arg = $ARGV[ $i + 1 ];
        $begin = eval { App::Clk::Util::resolve_instant($arg) };
        die "'$arg' is not a valid instant\n" if not defined $begin;
        $arg = $ARGV[ $i + 2 ];
        $end   = eval { App::Clk::Util::resolve_instant($arg) };
        die "'$arg' is not a valid instant\n" if not defined $end;
        splice @ARGV, $i, 3;    # remove the processed arguments
        next;
    }

    # found no known options.  move on to the next argument
    $i++;
}

search_by_time() if $begin or $end;

# default to searching by entry ID
my $entry_id = shift or die "No entry ID given\n";
die "A partial entry ID must be at least 3 characters long\n"
    if length($entry_id) < 3;

my $hash = substr $entry_id, 0, 2;
my $rest = substr $entry_id, 2;
if ( length $rest == 38 ) {  # full entry ID
    my $entry_filename = "$ENV{CLK_ROOT}/entries/$hash/$rest";
    if ( -e $entry_filename ) {
        emit($entry_filename);
        exit;
    }
}
else {  # partial entry ID
    my @entry_filenames = glob("$ENV{CLK_ROOT}/entries/$hash/$rest*");
    if ( @entry_filenames > 1 ) {
        warn "The partial entry ID '$entry_id' is ambiguous\n";
        exit 2;
    }
    elsif ( @entry_filenames == 1 ) {
        emit( $entry_filenames[0] );
        exit;
    }
}

exit 1;  # failure

sub emit {
    my ($entry_filename) = @_;
    ( my $entry_id = substr $entry_filename, -41 ) =~ y#/##d;
    if ( $outputting_content ) {
        print "id $entry_id\n";
        open my $fh, '<', $entry_filename
          or die "Couldn't open $entry_filename: $!\n";
        my $content = scalar do { local $/; <$fh> };
        printf "content %d\n%s", length($content), $content;
        return;
    }

    print "$entry_id\n";
    return;
}

sub search_by_time {
    our $begin;
    our $end;
    require App::Clk::Util;
    my $root = App::Clk::Util::clk_root();

    # open all the timelines
    my @timelines;
    while ( my $timeline_filename = glob("$root/timelines/*") ) {
        open my $fh, '<', $timeline_filename
            or die "Couldn't open timeline $timeline_filename: $!\n";
        push @timelines, $fh;
    }

    # these subs make the following code easier to understand
    my @matches;
    my $next_match = sub {
        my $i = shift;
        my $fh = $timelines[$i] or return;
        LOOP: {
            my $line = <$fh>;
            if ( not defined $line ) {  # finished reading this timeline
                $timelines[$i] = undef;
                return;
            }
            chomp $line;
            my ($hex_time, $entry_id) = split / /, $line;
            my $time = hex $hex_time;
            redo LOOP if $time < $begin;
            if ( $time > $end ) {
                $timelines[$i] = undef;
                return;
            }
            return [ $time, $entry_id ];
        };
    };

    # find the first match in each timeline
    $matches[$_] = $next_match->($_) for 0 .. $#timelines;

    # choose the earliest of the matches
    while ( grep { defined } @matches ) {
        my $earliest;
        my $earliest_index;
        for my $i ( 0 .. $#matches ) {
            my $match = $matches[$i] or next;
            if ( !$earliest or $match->[0] < $earliest->[0] ) {
                $earliest       = $match;
                $earliest_index = $i;
            }
        }
        last if not $earliest;  # no more matches

        # emit the earliest entry that we found
        my $entry_id = $earliest->[1];
        my $hash = substr $entry_id, 0, 2;
        my $rest = substr $entry_id, 2;
        emit("$root/entries/$hash/$rest");

        # find the next match in the timeline that provided the earliest
        $matches[$earliest_index] = $next_match->($earliest_index);
    }

    exit;
}

__END__

=head1 NAME

clk-entry-search - Search for entries created by clk-in

=head1 SYNOPSIS

B<clk entry-search> [--output 'content'] [id_pattern]

=head1 DESCRIPTION

Searches for entries which have been created by L<clk-in>.  C<id_pattern> is
either the 40 hexadecimal digit identifier for an entry or a unique prefix
thereof.  The prefix must be at least 3 characters long.

The entry ID for each matching entry is printed to STDOUT.

=head1 OPTIONS

=head2 --between begin end

Search for entries with times between C<begin> and C<end> (inclusive).  Each
argument should be a C<instant>.  See L<specs> for a list of valid formats.

=head2 --output 'content'

Instead of printing just the entry IDs to STDOUT, include the content of each
matching entry.  The output format looks like:

    id 123456789abcdefabcdefabcdefabcdefabcdefa
    content 38
    time: 2008-09-03T12:58:32Z
    text: hello

Each matching entry starts with a line

    id $entry_id

where C<$entry_id> is the entry's 40 hexadecimal digit unique identifier.
The following line is

    content $length

where C<$length> indicates the length of the entry's content.  That many
bytes worth of content follow the newline on the C<content> line.

=head1 EXIT CODES

 0   - At least one matching entry was found
 1   - No matching entries were found
 2   - A partial entry ID search was ambiguous
 255 - Improper invocation or another error was encountered.
       Details are provided on stderr.

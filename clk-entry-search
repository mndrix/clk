#!/usr/bin/perl
use strict;
use warnings;

# process command line arguments
my %acceptable_outputs = map { $_ => 1 } qw( content duration );
my %outputting;
our $begin;
our $end;
our $fsck;
my $i = 0;
while ( $i <= $#ARGV ) {
    if ( $ARGV[$i] eq '--output' ) {
        die "--output requires an argument\n" if $i + 1 > $#ARGV;
        my $spec = $ARGV[ $i + 1 ];
        for my $output ( split /,/, $spec ) {
            die "Invalid output kind: $output\n"
              unless $acceptable_outputs{$output};
            $outputting{$output} = 1;
        }
        splice @ARGV, $i, 2;    # remove the processed arguments
        next;
    }
    elsif ( $ARGV[$i] eq '--between' ) {
        die "--between requires two arguments\n" if $i + 2 > $#ARGV;
        require App::Clk::Util;
        local $@;
        my $arg = $ARGV[ $i + 1 ];
        $begin = eval { App::Clk::Util::resolve_instant($arg) };
        die "'$arg' is not a valid instant\n" if not defined $begin;
        $arg = $ARGV[ $i + 2 ];
        $end   = eval { App::Clk::Util::resolve_instant($arg) };
        die "'$arg' is not a valid instant\n" if not defined $end;
        splice @ARGV, $i, 3;    # remove the processed arguments
        next;
    }
    elsif ( $ARGV[$i] eq '--fsck' ) {
        $fsck = 1;
        splice @ARGV, $i, 1;    # remove the processed arguments
        next;
    }
    elsif ( $ARGV[$i] eq '--period' ) {
        die "--period requires an argument\n" if $i + 1 > $#ARGV;
        my $period = $ARGV[ $i + 1 ];
        require App::Clk::Util;
        local $@;
        ( $begin, $end ) = eval { App::Clk::Util::resolve_period($period) };
        die "'$period' is not a valid period\n" if not defined $begin;
        splice @ARGV, $i, 2;    # remove the processed arguments
        next;
    }

    # found no known options.  move on to the next argument
    $i++;
}

search_by_time() if $begin or $end;

# default to searching by entry ID
my $entry_id = shift;
if ( not defined $entry_id ) {
    require App::Clk::Util;
    ( $begin, $end ) = App::Clk::Util::resolve_period('ever');
    search_by_time();
}
die "A partial entry ID must be at least 3 characters long\n"
    if length($entry_id) < 3;

require App::Clk::Util;
if ( length $entry_id == 40 ) {  # full entry ID
    my $entry_filename =
      App::Clk::Util::hashed_path( $entry_id, '%r/entries/%h' );
    if ( -e $entry_filename ) {
        emit($entry_filename);
        exit;
    }
}
else {  # partial entry ID
    my @entry_filenames =
      glob( App::Clk::Util::hashed_path( $entry_id, '%r/entries/%h*' ) );
    if ( @entry_filenames > 1 ) {
        warn "The partial entry ID '$entry_id' is ambiguous\n";
        exit 2;
    }
    elsif ( @entry_filenames == 1 ) {
        emit( $entry_filenames[0] );
        exit;
    }
}

exit 1;  # failure

sub emit {
    my ($entry) = @_;
    my $entry_filename;
    if ( ref $entry ) {
        require App::Clk::Util;
        my $entry_id = $entry->[1];
        $entry_filename =
          App::Clk::Util::hashed_path( $entry_id, '%r/entries/%h' );
    }
    else {
        $entry_filename = $entry;
    }
    ( my $entry_id = substr $entry_filename, -41 ) =~ y#/##d;
    print "id $entry_id\n" if $outputting{content} or $outputting{duration};
    if ( $outputting{duration} ) {
        die "TODO: Cannot output duration for a single entry\n"
            if not ref $entry;
        my $next_entry = $entry->[2]->();
        my $next_time = $next_entry
                        ? $next_entry->[0]
                        : ( $ENV{CLK_TIME} || time )
                        ;
        printf "duration %d\n", $next_time - $entry->[0];
    }
    if ( $outputting{content} ) {
        open my $fh, '<', $entry_filename
          or die "Couldn't open $entry_filename: $!\n";
        my $content = scalar do { local $/; <$fh> };
        printf "content %d\n%s", length($content), $content;
    }
    return if $outputting{content} or $outputting{duration};

    print "$entry_id\n";
    return;
}

sub search_by_time {
    our $begin;
    our $end;
    require App::Clk::Util;

    # build an iterator representing all the timelines merged together
    my $timeline_root = App::Clk::Util::timeline_root( $ENV{CLK_IDENTITY} );
    my $timelines = timelines_new( glob("$timeline_root/*") );

    # find matching entries
    while ( my $entry = timelines_next($timelines) ) {
        next if $entry->[0] < $begin;  # too early
        last if $entry->[0] > $end;    # too late
        emit($entry);
    }

    exit;
}

sub timelines_new {
    my @timelines;
    for my $timeline_filename (@_) {
        push @timelines, timeline_new($timeline_filename);
    }
    return \@timelines;
}

sub timelines_next {
    my ($timelines, $peek) = @_;

    # choose the earliest entry among all the timelines
    my $earliest;
    my $earliest_index;
    my $i = 0;
    while ( $i <= $#$timelines ) {
        my $entry = timeline_peek( $timelines->[$i] );
        if ( not $entry ) {    # this timeline is empty
            splice @$timelines, $i, 1;    # don't increment $i
        }
        elsif ( !$earliest or $entry->[0] < $earliest->[0] ) {
            $earliest       = $entry;
            $earliest_index = $i++;
        }
        else {
            $i++;
        }
    }
    return if not $earliest;  # no more matches

    # are we only peeking?
    return timeline_peek( $timelines->[$earliest_index] ) if $peek;

    # ... nope, so consume the earliest entry that we found
    my $entry = timeline_next( $timelines->[$earliest_index] );
    $entry->[2] = sub { timelines_peek($timelines) };
    return $entry;
}

sub timelines_peek {
    my ($timelines) = @_;
    return timelines_next( $timelines, 'peek' );
}

sub timeline_new {
    my ($timeline_filename) = @_;
    my $size = -s $timeline_filename;
    open my $fh, '<', $timeline_filename
      or die "Couldn't open timeline $timeline_filename: $!\n";
    my $content = do { local $/; <$fh> };

    return {
        bullpen  => undef,
        position => 0,
        length   => $size,
        content  => $content,
    };
}

sub timeline_peek {
    my ($timeline) = @_;
    return $timeline->{bullpen} if defined $timeline->{bullpen};

    TRY: {
        # have we reached the end of the timeline?
        return if $timeline->{position} >= $timeline->{length};

        # extract and parse the line
        my $line = substr $timeline->{content}, $timeline->{position}, 49;
        $timeline->{position} += 50;
        if ( $fsck and $line !~ m/^[0-9a-f]{8} [0-9a-f]{40}$/o ) {
            # this line is mangled
            chomp $line;
            warn "Timeline entry is invalid: $line\n";
            redo TRY;
        }
        my ($hex_time, $entry_id) = split / /, $line;
        my $time = hex $hex_time;

        # is this line past the interesting lines?
        return $timeline->{bullpen} = [ $time, $entry_id ];
    };
}

sub timeline_next {
    my ($timeline) = @_;

    # do we already know what the next entry is?
    if ( my $next = $timeline->{bullpen} ) {
        $timeline->{bullpen} = undef;
        return $next;
    }

    # can we fetch the next entry?
    if ( my $next = timeline_peek($timeline) ) {
        $timeline->{bullpen} = undef;
        return $next;
    }

    # this timeline is empty, as far as we're concerned
    return;
}

__END__

=head1 NAME

clk-entry-search - Search for entries created by clk-in

=head1 SYNOPSIS

B<clk entry-search> [--output 'content'] [id_pattern]

=head1 DESCRIPTION

Searches for entries which have been created by L<clk-in>.  C<id_pattern> is
either the 40 hexadecimal digit identifier for an entry or a unique prefix
thereof.  If a prefix is given, it must be at least 3 characters long.  If no
C<id_pattern> is provided, all matching entries are considered.

The entry ID for each matching entry is printed to STDOUT.

=head1 OPTIONS

=head2 --between begin end

Search for entries with times between C<begin> and C<end> (inclusive).  Each
argument should be a C<instant>.  See L<specs> for a list of valid formats.

=head2 --fsck

This option should typically not be used directly.  Instead, call C<clk fsck>
to perform a variety of integrity checks.  When this option is used, it
verifies the integrity of the timelines.

=head2 --output 'content'

Instead of printing just the entry IDs to STDOUT, include the content of each
matching entry.  The output format looks like:

    id 123456789abcdefabcdefabcdefabcdefabcdefa
    content 38
    time: 2008-09-03T12:58:32Z
    text: hello

Each matching entry starts with a line

    id $entry_id

where C<$entry_id> is the entry's 40 hexadecimal digit unique identifier.
The following line is

    content $length

where C<$length> indicates the length of the entry's content.  That many
bytes worth of content follow the newline on the C<content> line.

=head2 --period period

Search for entries with times within the specified period.  The
argument should be a C<period>.  See L<specs> for a list of accepted periods.

=head1 EXIT CODES

 0   - At least one matching entry was found
 1   - No matching entries were found
 2   - A partial entry ID search was ambiguous
 255 - Improper invocation or another error was encountered.
       Details are provided on stderr.
